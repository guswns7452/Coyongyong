// 여기에 질문으로 연결되는걸 넣어줘야하네 생각해보니까... list로 넣으면 댐.
// chatGPT 만만세...하..

// const list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150];
// const titleList = ["1. 제목 : 니ㅏㄹ닝러ㅣ너", "우엥                                                            ", 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150]


// list 나타내는 js 코드
const hrefList = ['https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/', 'https://flowbite.com/docs/customize/colors/', 'https://flowbite.com/blocks/', 'https://www.todomate.net/#/', 'https://www.google.co.kr/', 'https://www.naver.com/'];

const humanList = ["user1", "user2", "user3", "user1", "user2", "user3", "user1", "user2", "user3", "user1", "user2", "user3"];

const titleList = ["title1", "title2", "title3", "title1", "title2", "title3", "title1", "title2", "title3", "title1", "title2", "title3"];

const contentList = [
    "Content of post 1Content of post 1Content of post 1Content of post 1Content of post 1Content of post 1Content of post 1Content of post 1Content of post 1Content of post 1Content of post 1Content of post 1Content of post 1",
    "Content of post 2",
    "Content of post 3", "Co ntent of post 1",
    "Content of post 2",
    "Content of post 3", "Content of post 1",
    "Content of post 2",
    "Content of post 3", "Content of post 1",
    "Content of post 2",
    "Content of post 3"
];

const imgList = ['yongsun.png', 'yongsun_makeup.png', 'fire_yongyong.png', 'water_yongyong.png', 'yongyong.png', 'nicon.png', 'uni.png', 'water_nicon.png', 'yongyong_nicon.png', 'full_heart_black.png', 'banner.png', 'appliance-repair.png']

const nameList = ['이다닷', '이다도리', '전현준', '김민지', '밍디', '이다현', '우지', '이지훈', '호시', '권순영', '에스쿱스', '최승철']

const watchingCountList = [33, 52, 15, 64, 57, 62, 63, 82, 26, 36, 82, 91]

const nowTimeList = ['2023.07.31', '2023.07.11', '2023.07.11', '2023.07.11', '2023.07.11', '2023.07.11', '2023.07.11', '2023.07.11', '2023.07.11', '2023.07.11', '2023.06.27', '2023.06.26']

const answerCountList = [5, 7, 4, 2, 5, 8, 9, 1, 6, 9, 2, 5]

const itemsPerPage = 10;
let currentPage = 1;

function displayList() {
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const paginatedList = titleList.slice(startIndex, endIndex);
    const listContainer = document.getElementById('listContainer');
    

    paginatedList.forEach((item, index) => {
        const listContent = contentList[startIndex + index] || ''; // 작성글 내용
        const imgSrc = imgList[startIndex + index] || 'appliance-repair.png'; // 이미지 소스
        const authorName = nameList[startIndex + index] || ''; // 작성자 이름
        const watchingCount = watchingCountList[startIndex + index] || 0;
        const nowTime = nowTimeList[startIndex + index] || '';
        const answerCount = answerCountList[startIndex + index] || 0;

      

        
    });

    displayPagination();
}



function displayPagination() {
    const paginationContainer = document.getElementById('pagination');
    paginationContainer.innerHTML = '';

    const totalPages = Math.ceil(humanList.length / itemsPerPage);

    if (currentPage > 1) {
        const previousButton = createPaginationButton('Previous', currentPage - 1);
        paginationContainer.appendChild(previousButton);
    }

    const visiblePages = getVisiblePages();
    visiblePages.forEach(page => {
        const pageButton = createPaginationButton(page, page);
        paginationContainer.appendChild(pageButton);
    });

    if (currentPage < totalPages) {
        const nextButton = createPaginationButton('Next', currentPage + 1);
        paginationContainer.appendChild(nextButton);
    }
}

function createPaginationButton(text, page) {
    const button = document.createElement('li');
    const link = document.createElement('a');
    link.textContent = text;
    link.href = '#';
    link.addEventListener('click', (event) => {
        event.preventDefault(); // 기본 동작 방지
        currentPage = page; // currentPage 업데이트
        displayList(); // 목록 업데이트
        displayPagination(); // 페이지 버튼 업데이트
    });
    button.appendChild(link);
    button.classList.add('pagination-button'); // 페이지 버튼에 클래스 추가
    return button;
}




function getVisiblePages() {
    const totalPages = Math.ceil(humanList.length / itemsPerPage);
    let startPage = Math.max(currentPage - 2, 1);
    let endPage = Math.min(currentPage + 2, totalPages);

    if (endPage - startPage < 4) {
        if (startPage === 1) {
            endPage = Math.min(startPage + 4, totalPages);
        } else {
            startPage = Math.max(endPage - 4, 1);
        }
    }

    return Array.from({ length: endPage - startPage + 1 }, (_, i) => startPage + i);
}

window.addEventListener('DOMContentLoaded', () => {
    displayList();
    displayPagination();
});


// 언어 선택하기 코드
const wrappers = document.querySelectorAll(".wrapper");
const arrowBtns = document.querySelectorAll(".wrapper i");

wrappers.forEach((wrapper, index) => {
    const carousel = wrapper.querySelector(".carousel");
    const firstCardWidth = carousel.querySelector(".card").offsetWidth;
    const leftBtn = wrapper.querySelector("i#left");
    const rightBtn = wrapper.querySelector("i#right");

    let isDragging = false,
        isAutoPlay = true,
        startX,
        startScrollLeft,
        timeoutId;

    // Get the number of cards that can fit in the carousel at once
    let cardPerView = Math.round(carousel.offsetWidth / firstCardWidth);

    // Insert copies of the last few cards to the beginning of the carousel for infinite scrolling
    const carouselChildrens = [...carousel.children];
    carouselChildrens.slice(-cardPerView).reverse().forEach(card => {
        carousel.insertAdjacentHTML("afterbegin", card.outerHTML);
    });

    // Insert copies of the first few cards to the end of the carousel for infinite scrolling
    carouselChildrens.slice(0, cardPerView).forEach(card => {
        carousel.insertAdjacentHTML("beforeend", card.outerHTML);
    });

    // Scroll the carousel at the appropriate position to hide the first few duplicate cards on Firefox
    carousel.classList.add("no-transition");
    carousel.scrollLeft = carousel.offsetWidth;
    carousel.classList.remove("no-transition");

    // Add event listener for the left button to scroll the carousel left
    leftBtn.addEventListener("click", () => {
        carousel.scrollLeft -= firstCardWidth;
    });

    // Add event listener for the right button to scroll the carousel right
    rightBtn.addEventListener("click", () => {
        carousel.scrollLeft += firstCardWidth;
    });

    const dragStart = (e) => {
        isDragging = true;
        carousel.classList.add("dragging");
        // Record the initial cursor and scroll position of the carousel
        startX = e.pageX;
        startScrollLeft = carousel.scrollLeft;
    }

    const dragging = (e) => {
        if (!isDragging) return; // If isDragging is false, return
        // Update the scroll position of the carousel based on the cursor movement
        carousel.scrollLeft = startScrollLeft - (e.pageX - startX);
    }

    const dragStop = () => {
        isDragging = false;
        carousel.classList.remove("dragging");
    }

    const infiniteScroll = () => {
        // If the carousel is at the beginning, scroll to the end
        if (carousel.scrollLeft === 0) {
            carousel.classList.add("no-transition");
            carousel.scrollLeft = carousel.scrollWidth - (2 * carousel.offsetWidth);
            carousel.classList.remove("no-transition");
        }
        // If the carousel is at the end, scroll to the beginning
        else if (Math.ceil(carousel.scrollLeft) === carousel.scrollWidth - carousel.offsetWidth) {
            carousel.classList.add("no-transition");
            carousel.scrollLeft = carousel.offsetWidth;
            carousel.classList.remove("no-transition");
        }

        // Clear the existing timeout and start autoplay if the mouse is not hovering over the carousel
        clearTimeout(timeoutId);
        if (!wrapper.matches(":hover")) autoPlay();
    }

    // const autoPlay = () => {
    //     if (window.innerWidth < 800 || !isAutoPlay) return; // Return if the window is smaller than 800 or isAutoPlay is false
    //     // Autoplay the carousel after every 2500 ms
    //     timeoutId = setTimeout(() => {
    //         const newPosition = carousel.scrollLeft + firstCardWidth;
    //         carousel.scrollTo({
    //             left: newPosition,
    //             behavior: "smooth"
    //         });
    //     }, 2500);
    // }
    //  autoPlay();

    carousel.addEventListener("mousedown", dragStart);
    carousel.addEventListener("mousemove", dragging);
    document.addEventListener("mouseup", dragStop);
    carousel.addEventListener("scroll", infiniteScroll);
    wrapper.addEventListener("mouseenter", () => clearTimeout(timeoutId));
    wrapper.addEventListener("mouseleave", autoPlay);
});